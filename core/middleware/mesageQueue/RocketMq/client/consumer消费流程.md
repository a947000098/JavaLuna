## 一、用法：

### 步骤：rocketmq消费的用法分为两步

#### 1、初始化consumer，包含相应的必填配置

|/*<br>* Instantiate with specified consumer group name. 初始化消费分组<br>*/<br>DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name_4");<br><br>/*<br>* Specify name server addresses. 指定nameSrv<br>* <p/><br>*<br>* Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR<br>* <pre><br>* {@code<br>* consumer.setNamesrvAddr("name-server1-ip:9876;name-server2-ip:9876");<br>* }<br>* </pre><br>*/<br><br>/*<br>* Specify where to start in case the specified consumer group is a brand new one. 指定从哪开始消费<br>*/<br>consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);<br><br>/*<br>* Subscribe one more more topics to consume. 指定topic和tag<br>*/<br>consumer.subscribe("TopicTest", "*");<br><br>/*<br>*  Register callback to execute on arrival of messages fetched from brokers. 消费到消息后的业务逻辑<br>*/<br>consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {<br>System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);<br>return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>});|
|:----|

2、启动消费者（相当于启动一个线程，这个线程的run方法会源源不断的拉取message）

|/*<br>*  Launch the consumer instance. 启动消费者线程<br>*/<br>consumer.start();|
|:----|
## 二、模块分解

### 一、Client端

|public synchronized void start() throws MQClientException {<br>switch (this.serviceState) {<br>case CREATE_JUST:<br>log.info("the consumer [{}] start beginning. messageModel={}, isUnitMode={}", this.defaultMQPushConsumer.getConsumerGroup(),<br>this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());<br>this.serviceState = ServiceState.START_FAILED;<br><br>//1. 检查配置<br>this.checkConfig();<br>//2. copy订阅消息到本地<br>this.copySubscription();<br><br>if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {<br>//<br>this.defaultMQPushConsumer.changeInstanceNameToPID();<br>}<br><br>//3. 封装mqClient<br>this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);<br><br>//4. 封装负载均衡类<br>this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());<br>this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());<br>this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());<br>this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);<br><br>//5. 封装apiWrapper类<br>this.pullAPIWrapper = new PullAPIWrapper(mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());<br>//注册hook<br>this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);<br><br><br>//6. 获取位点相关类并加载<br>if (this.defaultMQPushConsumer.getOffsetStore() != null) {<br>this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();<br>} else {<br>switch (this.defaultMQPushConsumer.getMessageModel()) {<br>case BROADCASTING:<br>this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());<br>break;<br>case CLUSTERING:<br>this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());<br>break;<br>default:<br>break;<br>}<br>this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);<br>}<br>this.offsetStore.load();<br><br>//7. 初始化消费模式<br>if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {<br>//顺序消费模式<br>this.consumeOrderly = true;<br>this.consumeMessageService = new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());<br>} else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {<br>//并发消费模式<br>this.consumeOrderly = false;<br>this.consumeMessageService = new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());<br>}<br><br>//并发消费模式启动需要对队列上锁<br>//顺序消费模式启动需要定时清理过期消息<br>this.consumeMessageService.start();<br><br><br>//8. 将该类缓存到本地<br>boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);<br>if (!registerOK) {<br>this.serviceState = ServiceState.CREATE_JUST;<br>this.consumeMessageService.shutdown();<br>throw new MQClientException("The consumer group[" + this.defaultMQPushConsumer.getConsumerGroup()<br>+ "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),<br>null);<br>}<br><br>//9. 启动内部的mqClient<br>mQClientFactory.start();<br>log.info("the consumer [{}] start OK.", this.defaultMQPushConsumer.getConsumerGroup());<br>this.serviceState = ServiceState.RUNNING;<br>break;<br>case RUNNING:<br>case START_FAILED:<br>case SHUTDOWN_ALREADY:<br>throw new MQClientException("The PushConsumer service state not OK, maybe started once, "<br>+ this.serviceState<br>+ FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),<br>null);<br>default:<br>break;<br>}<br>//更新topic的订阅信息当订阅信息改变<br>this.updateTopicSubscribeInfoWhenSubscriptionChanged();<br>//检查tagType<br>this.mQClientFactory.checkClientInBroker();<br>//发送心跳消息到所有broker（上锁）<br>this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();<br>//唤醒负载均衡服务<br>this.mQClientFactory.rebalanceImmediately();<br>}|
|:----|


|public void start() throws MQClientException {<br>synchronized (this) {<br>switch (this.serviceState) {<br>case CREATE_JUST:<br>this.serviceState = ServiceState.START_FAILED;<br>// If not specified,looking address from name server<br>if (null == this.clientConfig.getNamesrvAddr()) {<br>this.mQClientAPIImpl.fetchNameServerAddr();<br>}<br>//<br>// Start request-response channel<br>// 和broker开启长连接<br>this.mQClientAPIImpl.start();<br>// Start various schedule tasks<br>// 开启定时任务<br>this.startScheduledTask();<br>// Start pull service<br>// 开启拉取服务<br>this.pullMessageService.start();<br>// Start rebalance service<br>// 开启负载均衡服务<br>this.rebalanceService.start();<br>// Start push service<br>this.defaultMQProducer.getDefaultMQProducerImpl().start(false);<br>log.info("the client factory [{}] start OK", this.clientId);<br>this.serviceState = ServiceState.RUNNING;<br>break;<br>case START_FAILED:<br>throw new MQClientException("The Factory object[" + this.getClientId() + "] has been created before, and failed.", null);<br>default:<br>break;<br>}<br>}<br>}<br><br>|
|:----|


|/**<br>* 核心拉取Message类<br>*/<br>@Override<br>public void run() {<br>log.info(this.getServiceName() + " service started");<br><br>while (!this.isStopped()) {<br>try {<br>//从拉去请求队列中取出一个请求<br>PullRequest pullRequest = this.pullRequestQueue.take();<br>//开始拉取message核心逻辑<br>this.pullMessage(pullRequest);<br>} catch (InterruptedException ignored) {<br>} catch (Exception e) {<br>log.error("Pull Message Service Run Method exception", e);<br>}<br>}<br><br>log.info(this.getServiceName() + " service end");<br>}<br><br>|
|:----|


|private void pullMessage(final PullRequest pullRequest) {<br>//根据之前缓存的group -> DefaultMQPushConsumerImpl<br>final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());<br>if (consumer != null) {<br>DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;<br>impl.pullMessage(pullRequest);<br>} else {<br>log.warn("No matched consumer for the PullRequest {}, drop it", pullRequest);<br>}<br>}|
|:----|


|public void pullMessage(final PullRequest pullRequest) {<br>//获取消费队列快照<br>final ProcessQueue processQueue = pullRequest.getProcessQueue();<br>//如果该快照已被丢弃则打印日志并返回<br>if (processQueue.isDropped()) {<br>log.info("the pull request[{}] is dropped.", pullRequest.toString());<br>return;<br>}<br><br>//设置最近的pull时间<br>pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());<br><br>try {<br>//确保消费者状态ok<br>this.makeSureStateOK();<br>} catch (MQClientException e) {<br>log.warn("pullMessage exception, consumer state not ok", e);<br>this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);<br>return;<br>}<br><br>//如果消息消费服务中断则返回<br>if (this.isPause()) {<br>log.warn("consumer was paused, execute pull request later. instanceName={}, group={}", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());<br>this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);<br>return;<br>}<br><br>//缓存消息数量<br>long cachedMessageCount = processQueue.getMsgCount().get();<br>//缓存消息大小单位MB<br>long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);<br><br>//消息数量大于阈值 流控<br>if (cachedMessageCount > this.defaultMQPushConsumer.getPullThresholdForQueue()) {<br>this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);<br>if ((queueFlowControlTimes++ % 1000) == 0) {<br>log.warn("the cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}",<br>this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);<br>}<br>return;<br>}<br><br>//消息大小大于阈值 流控<br>if (cachedMessageSizeInMiB > this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) {<br>this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);<br>if ((queueFlowControlTimes++ % 1000) == 0) {<br>log.warn("the cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}",<br>this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);<br>}<br>return;<br>}<br><br>//消息跨度大于阈值且消费非有序 流控<br>if (!this.consumeOrderly) {<br>if (processQueue.getMaxSpan() > this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {<br>this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);<br>if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) {<br>log.warn("the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}",<br>processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),<br>pullRequest, queueMaxSpanFlowControlTimes);<br>}<br>return;<br>}<br>} else {<br>if (processQueue.isLocked()) {<br>//处理队列上锁<br>if (!pullRequest.isLockedFirst()) {<br>//计算拉取消息的位点<br>final long offset = this.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());<br><br>boolean brokerBusy = offset < pullRequest.getNextOffset();<br>log.info("the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}", pullRequest, offset, brokerBusy);<br>if (brokerBusy) {<br>log.info("[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}", pullRequest, offset);<br>}<br><br>pullRequest.setLockedFirst(true);<br>pullRequest.setNextOffset(offset);<br>}<br>} else {<br>this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);<br>log.info("pull message later because not locked in broker, {}", pullRequest);<br>return;<br>}<br>}<br><br>final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());<br>if (null == subscriptionData) {<br>this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);<br>log.warn("find the consumer's subscription failed, {}", pullRequest);<br>return;<br>}<br><br>final long beginTimestamp = System.currentTimeMillis();<br><br>//pull后的回调函数<br>PullCallback pullCallback = new PullCallback() {<br>@Override<br>public void onSuccess(PullResult pullResult) {<br>if (pullResult != null) {<br>pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,<br>subscriptionData);<br><br>switch (pullResult.getPullStatus()) {<br>case FOUND:<br>long prevRequestOffset = pullRequest.getNextOffset();<br>pullRequest.setNextOffset(pullResult.getNextBeginOffset());<br>long pullRT = System.currentTimeMillis() - beginTimestamp;<br>DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),<br>pullRequest.getMessageQueue().getTopic(), pullRT);<br><br>long firstMsgOffset = Long.MAX_VALUE;<br>if (pullResult.getMsgFoundList() == null \|\| pullResult.getMsgFoundList().isEmpty()) {<br>DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);<br>} else {<br>firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();<br><br>DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),<br>pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());<br><br>boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());<br>DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(<br>pullResult.getMsgFoundList(),<br>processQueue,<br>pullRequest.getMessageQueue(),<br>dispatchToConsume);<br><br>if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) {<br>DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,<br>DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());<br>} else {<br>DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);<br>}<br>}<br><br>if (pullResult.getNextBeginOffset() < prevRequestOffset<br>\|\| firstMsgOffset < prevRequestOffset) {<br>log.warn(<br>"[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}",<br>pullResult.getNextBeginOffset(),<br>firstMsgOffset,<br>prevRequestOffset);<br>}<br><br>break;<br>case NO_NEW_MSG:<br>case NO_MATCHED_MSG:<br>pullRequest.setNextOffset(pullResult.getNextBeginOffset());<br><br>DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);<br><br>DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);<br>break;<br><br>case OFFSET_ILLEGAL:<br>log.warn("the pull request offset illegal, {} {}",<br>pullRequest.toString(), pullResult.toString());<br>pullRequest.setNextOffset(pullResult.getNextBeginOffset());<br><br>pullRequest.getProcessQueue().setDropped(true);<br>DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() {<br><br>@Override<br>public void run() {<br>try {<br>DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),<br>pullRequest.getNextOffset(), false);<br><br>DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());<br><br>DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());<br><br>log.warn("fix the pull request offset, {}", pullRequest);<br>} catch (Throwable e) {<br>log.error("executeTaskLater Exception", e);<br>}<br>}<br>}, 10000);<br>break;<br>default:<br>break;<br>}<br>}<br>}<br><br>@Override<br>public void onException(Throwable e) {<br>if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {<br>log.warn("execute the pull request exception", e);<br>}<br><br>DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);<br>}<br>};<br><br>boolean commitOffsetEnable = false;<br>long commitOffsetValue = 0L;<br>if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) {<br>//从本地的存储文件中读取位点<br>commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);<br>if (commitOffsetValue > 0) {<br>//如果读取位点>0 则提交位点开关开启<br>commitOffsetEnable = true;<br>}<br>}<br><br>String subExpression = null;<br>boolean classFilter = false;<br>SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());<br>if (sd != null) {<br>if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() && !sd.isClassFilterMode()) {<br>subExpression = sd.getSubString();<br>}<br>classFilter = sd.isClassFilterMode();<br>}<br><br>int sysFlag = PullSysFlag.buildSysFlag(<br>commitOffsetEnable, // commitOffset<br>true, // suspend<br>subExpression != null, // subscription<br>classFilter // class filter<br>);<br>try {<br>this.pullAPIWrapper.pullKernelImpl(<br>pullRequest.getMessageQueue(),<br>subExpression,<br>subscriptionData.getExpressionType(),<br>subscriptionData.getSubVersion(),<br>pullRequest.getNextOffset(),<br>this.defaultMQPushConsumer.getPullBatchSize(),<br>sysFlag,<br>commitOffsetValue,<br>BROKER_SUSPEND_MAX_TIME_MILLIS,<br>CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,<br>CommunicationMode.ASYNC,<br>pullCallback<br>);<br>} catch (Exception e) {<br>log.error("pullKernelImpl exception", e);<br>this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);<br>}<br>}<br><br>|
|:----|


|public PullResult pullKernelImpl(<br>final MessageQueue mq,<br>final String subExpression,<br>final String expressionType,<br>final long subVersion,<br>final long offset,<br>final int maxNums,<br>final int sysFlag,<br>final long commitOffset,<br>final long brokerSuspendMaxTimeMillis,<br>final long timeoutMillis,<br>final CommunicationMode communicationMode,<br>final PullCallback pullCallback<br>) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {<br>//根据brokerName和brokerId获取broker信息<br>FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), this.recalculatePullFromWhichNode(mq), false);<br>if (null == findBrokerResult) {<br>//为空则从nameSrv中拉取最新的topic陆游信息<br>this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());<br>findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), this.recalculatePullFromWhichNode(mq), false);<br>}<br><br>if (findBrokerResult != null) {<br>// check version<br>if (!ExpressionType.isTagType(expressionType) && findBrokerResult.getBrokerVersion() < MQVersion.Version.V4_1_0_SNAPSHOT.ordinal()) {<br>throw new MQClientException("The broker[" + mq.getBrokerName() + ", " + findBrokerResult.getBrokerVersion() + "] does not upgrade to support for filter message by " + expressionType, null);<br>}<br><br>int sysFlagInner = sysFlag;<br>if (findBrokerResult.isSlave()) {<br>sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);<br>}<br><br>//封装拉取信息请求头<br>PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();<br>requestHeader.setConsumerGroup(this.consumerGroup);<br>requestHeader.setTopic(mq.getTopic());<br>requestHeader.setQueueId(mq.getQueueId());<br>requestHeader.setQueueOffset(offset);<br>requestHeader.setMaxMsgNums(maxNums);<br>requestHeader.setSysFlag(sysFlagInner);<br>requestHeader.setCommitOffset(commitOffset);<br>requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);<br>requestHeader.setSubscription(subExpression);<br>requestHeader.setSubVersion(subVersion);<br>requestHeader.setExpressionType(expressionType);<br><br>//获取brokerAddr<br>String brokerAddr = findBrokerResult.getBrokerAddr();<br>//获取有filterServer的BrokerAddr<br>if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) {<br>brokerAddr = computePullFromWhichFilterServer(mq.getTopic(), brokerAddr);<br>}<br><br>return this.mQClientFactory.getMQClientAPIImpl().pullMessage(<br>brokerAddr,<br>requestHeader,<br>timeoutMillis,<br>communicationMode,<br>pullCallback);<br>}<br><br>throw new MQClientException("The broker[" + mq.getBrokerName() + "] not exist", null);<br>}<br><br>|
|:----|


|public PullResult pullMessage(<br>final String addr,<br>final PullMessageRequestHeader requestHeader,<br>final long timeoutMillis,<br>final CommunicationMode communicationMode,<br>final PullCallback pullCallback<br>) throws RemotingException, MQBrokerException, InterruptedException {<br>RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, requestHeader);<br><br>switch (communicationMode) {<br>case ONEWAY:<br>//忽略返回值<br>assert false;<br>return null;<br>case ASYNC:<br>//异步pullMessage<br>this.pullMessageAsync(addr, request, timeoutMillis, pullCallback);<br>return null;<br>case SYNC:<br>//同步pullMessage<br>return this.pullMessageSync(addr, request, timeoutMillis);<br>default:<br>assert false;<br>break;<br>}<br><br>return null;<br>}|
|:----|


|private void pullMessageAsync(<br>final String addr,<br>final RemotingCommand request,<br>final long timeoutMillis,<br>final PullCallback pullCallback<br>) throws RemotingException, InterruptedException {<br>//netty客户端向broker异步发起请求<br>this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() {<br>@Override<br>public void operationComplete(ResponseFuture responseFuture) {<br>RemotingCommand response = responseFuture.getResponseCommand();<br>if (response != null) {<br>try {<br>PullResult pullResult = MQClientAPIImpl.this.processPullResponse(response);<br>pullCallback.onSuccess(pullResult);<br>} catch (Exception e) {<br>pullCallback.onException(e);<br>}<br>} else {<br>if (!responseFuture.isSendRequestOK()) {<br>pullCallback.onException(new MQClientException("send request failed to " + addr + ". Request: " + request, responseFuture.getCause()));<br>} else if (responseFuture.isTimeout()) {<br>pullCallback.onException(new MQClientException("wait response from " + addr + " timeout :" + responseFuture.getTimeoutMillis() + "ms" + ". Request: " + request,<br>responseFuture.getCause()));<br>} else {<br>pullCallback.onException(new MQClientException("unknown reason. addr: " + addr + ", timeoutMillis: " + timeoutMillis + ". Request: " + request, responseFuture.getCause()));<br>}<br>}<br>}<br>});<br>}|
|:----|
### 二、broker端

|private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend) throws RemotingCommandException {<br>//创建返回命令<br>RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);<br>//读取response的自定义字段生成返回头<br>final PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();<br>//解码自定义字段生成拉取消息请求头<br>final PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);<br><br>response.setOpaque(request.getOpaque());<br><br>log.debug("receive PullMessage request command, {}", request);<br><br>//判断当前的broker是否有权限<br>if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {<br>response.setCode(ResponseCode.NO_PERMISSION);<br>response.setRemark(String.format("the broker[%s] pulling message is forbidden", this.brokerController.getBrokerConfig().getBrokerIP1()));<br>return response;<br>}<br><br>//获取订阅组配置并开始校验<br>SubscriptionGroupConfig subscriptionGroupConfig = this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());<br>if (null == subscriptionGroupConfig) {<br>response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);<br>response.setRemark(String.format("subscription group [%s] does not exist, %s", requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));<br>return response;<br>}<br>if (!subscriptionGroupConfig.isConsumeEnable()) {<br>response.setCode(ResponseCode.NO_PERMISSION);<br>response.setRemark("subscription group no permission, " + requestHeader.getConsumerGroup());<br>return response;<br>}<br><br>//是否已经暂停<br>final boolean hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag());<br>//是否已经提交位点<br>final boolean hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag());<br>//是否已订阅<br>final boolean hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag());<br>//是否暂停超时<br>final long suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : 0;<br><br>//获取topic配置并开始校验<br>TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());<br>if (null == topicConfig) {<br>log.error("the topic {} not exist, consumer: {}", requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel));<br>response.setCode(ResponseCode.TOPIC_NOT_EXIST);<br>response.setRemark(String.format("topic[%s] not exist, apply first please! %s", requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));<br>return response;<br>}<br>if (!PermName.isReadable(topicConfig.getPerm())) {<br>response.setCode(ResponseCode.NO_PERMISSION);<br>response.setRemark("the topic[" + requestHeader.getTopic() + "] pulling message is forbidden");<br>return response;<br>}<br>if (requestHeader.getQueueId() < 0 \|\| requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {<br>String errorInfo = String.format("queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]",<br>requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress());<br>log.warn(errorInfo);<br>response.setCode(ResponseCode.SYSTEM_ERROR);<br>response.setRemark(errorInfo);<br>return response;<br>}<br><br>SubscriptionData subscriptionData;<br>ConsumerFilterData consumerFilterData = null;<br>if (hasSubscriptionFlag) {<br>//已订阅则构建订阅类型数据和消费端过滤器<br>try {<br>subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getSubscription(), requestHeader.getExpressionType());<br>if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {<br>consumerFilterData = ConsumerFilterManager.build(requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getSubscription(),<br>requestHeader.getExpressionType(), requestHeader.getSubVersion()<br>);<br>assert consumerFilterData != null;<br>}<br>} catch (Exception e) {<br>log.warn("Parse the consumer's subscription[{}] failed, group: {}", requestHeader.getSubscription(), requestHeader.getConsumerGroup());<br>response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);<br>response.setRemark("parse the consumer's subscription failed");<br>return response;<br>}<br>} else {<br>//未订阅则获取消费组信息<br>ConsumerGroupInfo consumerGroupInfo = this.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup());<br>if (null == consumerGroupInfo) {<br>log.warn("the consumer's group info not exist, group: {}", requestHeader.getConsumerGroup());<br>response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);<br>response.setRemark("the consumer's group info not exist" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));<br>return response;<br>}<br>//是否是广播消费方式<br>if (!subscriptionGroupConfig.isConsumeBroadcastEnable() && consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) {<br>response.setCode(ResponseCode.NO_PERMISSION);<br>response.setRemark("the consumer group[" + requestHeader.getConsumerGroup() + "] can not consume by broadcast way");<br>return response;<br>}<br><br>subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic());<br>if (null == subscriptionData) {<br>//订阅类型数据为空<br>log.warn("the consumer's subscription not exist, group: {}, topic:{}", requestHeader.getConsumerGroup(), requestHeader.getTopic());<br>response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);<br>response.setRemark("the consumer's subscription not exist" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));<br>return response;<br>}<br><br>if (subscriptionData.getSubVersion() < requestHeader.getSubVersion()) {<br>//broker的订阅不是最新<br>log.warn("The broker's subscription is not latest, group: {} {}", requestHeader.getConsumerGroup(), subscriptionData.getSubString());<br>response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST);<br>response.setRemark("the consumer's subscription not latest");<br>return response;<br>}<br>if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {<br>consumerFilterData = this.brokerController.getConsumerFilterManager().get(requestHeader.getTopic(), requestHeader.getConsumerGroup());<br>if (consumerFilterData == null) {<br>response.setCode(ResponseCode.FILTER_DATA_NOT_EXIST);<br>response.setRemark("The broker's consumer filter data is not exist!Your expression may be wrong!");<br>return response;<br>}<br>if (consumerFilterData.getClientVersion() < requestHeader.getSubVersion()) {<br>log.warn("The broker's consumer filter data is not latest, group: {}, topic: {}, serverV: {}, clientV: {}",<br>requestHeader.getConsumerGroup(), requestHeader.getTopic(), consumerFilterData.getClientVersion(), requestHeader.getSubVersion());<br>response.setCode(ResponseCode.FILTER_DATA_NOT_LATEST);<br>response.setRemark("the consumer's consumer filter data not latest");<br>return response;<br>}<br>}<br>}<br><br>if (!ExpressionType.isTagType(subscriptionData.getExpressionType()) && !this.brokerController.getBrokerConfig().isEnablePropertyFilter()) {<br>response.setCode(ResponseCode.SYSTEM_ERROR);<br>response.setRemark("The broker does not support consumer to filter message by " + subscriptionData.getExpressionType());<br>return response;<br>}<br><br>MessageFilter messageFilter;<br>if (this.brokerController.getBrokerConfig().isFilterSupportRetry()) {<br>//<br>messageFilter = new ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData, this.brokerController.getConsumerFilterManager());<br>} else {<br>messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData, this.brokerController.getConsumerFilterManager());<br>}<br><br>//核心查询消息逻辑<br>final GetMessageResult getMessageResult = this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),<br>requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter);<br>if (getMessageResult != null) {<br>//设置查询标志<br>response.setRemark(getMessageResult.getStatus().name());<br>//设置下一个开始的位点<br>responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());<br>//设置最小位点<br>responseHeader.setMinOffset(getMessageResult.getMinOffset());<br>//设置最大位点<br>responseHeader.setMaxOffset(getMessageResult.getMaxOffset());<br><br>if (getMessageResult.isSuggestPullingFromSlave()) {<br>//支持从Slave拉取message<br>responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());<br>} else {<br>//不支持则设置master<br>responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);<br>}<br><br>switch (this.brokerController.getMessageStoreConfig().getBrokerRole()) {<br>case SLAVE:<br>if (!this.brokerController.getBrokerConfig().isSlaveReadEnable()) {<br>//slave读开关关闭则标记为立即重试，重试节点为master<br>response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);<br>responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);<br>}<br>break;<br>case ASYNC_MASTER:<br>case SYNC_MASTER:<br>default:<br>break;<br>}<br><br>if (this.brokerController.getBrokerConfig().isSlaveReadEnable()) {<br>//开启slave读开关<br>// consume too slow ,redirect to another machine<br>if (getMessageResult.isSuggestPullingFromSlave()) {<br>responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());<br>}<br>// consume ok<br>else {<br>responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());<br>}<br>} else {<br>responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);<br>}<br><br>switch (getMessageResult.getStatus()) {<br>case FOUND:<br>//成功找到<br>response.setCode(ResponseCode.SUCCESS);<br>break;<br>case MESSAGE_WAS_REMOVING:<br>//消息正在删除<br>case NO_MATCHED_MESSAGE:<br>response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);<br>break;<br>case NO_MATCHED_LOGIC_QUEUE:<br>//没有匹配的逻辑队列<br>case NO_MESSAGE_IN_QUEUE:<br>//队列中没有匹配的消息<br>if (0 != requestHeader.getQueueOffset()) {<br>response.setCode(ResponseCode.PULL_OFFSET_MOVED);<br><br>// XXX: warn and notify me<br>log.info("the broker store no queue data, fix the request offset {} to {}, Topic: {} QueueId: {} Consumer Group: {}",<br>requestHeader.getQueueOffset(),<br>getMessageResult.getNextBeginOffset(),<br>requestHeader.getTopic(),<br>requestHeader.getQueueId(),<br>requestHeader.getConsumerGroup()<br>);<br>} else {<br>response.setCode(ResponseCode.PULL_NOT_FOUND);<br>}<br>break;<br>case OFFSET_FOUND_NULL:<br>//未找到位点<br>case OFFSET_OVERFLOW_ONE:<br>//位点越界<br>response.setCode(ResponseCode.PULL_NOT_FOUND);<br>break;<br>case OFFSET_OVERFLOW_BADLY:<br>//位点越界<br>response.setCode(ResponseCode.PULL_OFFSET_MOVED);<br>// XXX: warn and notify me<br>log.info("the request offset: {} over flow badly, broker max offset: {}, consumer: {}",<br>requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());<br>break;<br>case OFFSET_TOO_SMALL:<br>//位点太小<br>response.setCode(ResponseCode.PULL_OFFSET_MOVED);<br>log.info("the request offset too small. group={}, topic={}, requestOffset={}, brokerMinOffset={}, clientIp={}",<br>requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),<br>getMessageResult.getMinOffset(), channel.remoteAddress());<br>break;<br>default:<br>assert false;<br>break;<br>}<br><br>if (this.hasConsumeMessageHook()) {<br>ConsumeMessageContext context = new ConsumeMessageContext();<br>context.setConsumerGroup(requestHeader.getConsumerGroup());<br>context.setTopic(requestHeader.getTopic());<br>context.setQueueId(requestHeader.getQueueId());<br><br>String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);<br><br>switch (response.getCode()) {<br>case ResponseCode.SUCCESS:<br>int commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();<br>int incValue = getMessageResult.getMsgCount4Commercial() * commercialBaseCount;<br><br>context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_SUCCESS);<br>context.setCommercialRcvTimes(incValue);<br>context.setCommercialRcvSize(getMessageResult.getBufferTotalSize());<br>context.setCommercialOwner(owner);<br><br>break;<br>case ResponseCode.PULL_NOT_FOUND:<br>if (!brokerAllowSuspend) {<br><br>context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);<br>context.setCommercialRcvTimes(1);<br>context.setCommercialOwner(owner);<br><br>}<br>break;<br>case ResponseCode.PULL_RETRY_IMMEDIATELY:<br>case ResponseCode.PULL_OFFSET_MOVED:<br>context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);<br>context.setCommercialRcvTimes(1);<br>context.setCommercialOwner(owner);<br>break;<br>default:<br>assert false;<br>break;<br>}<br><br>this.executeConsumeMessageHookBefore(context);<br>}<br><br>switch (response.getCode()) {<br>case ResponseCode.SUCCESS:<br><br>this.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(), getMessageResult.getMessageCount());<br><br>this.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(), getMessageResult.getBufferTotalSize());<br><br>this.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());<br>if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {<br>final long beginTimeMills = this.brokerController.getMessageStore().now();<br>final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());<br>this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),<br>requestHeader.getTopic(), requestHeader.getQueueId(),<br>(int) (this.brokerController.getMessageStore().now() - beginTimeMills));<br>response.setBody(r);<br>} else {<br>try {<br>FileRegion fileRegion = new ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);<br>channel.writeAndFlush(fileRegion).addListener(new ChannelFutureListener() {<br>@Override<br>public void operationComplete(ChannelFuture future) throws Exception {<br>getMessageResult.release();<br>if (!future.isSuccess()) {<br>log.error("transfer many message by pagecache failed, {}", channel.remoteAddress(), future.cause());<br>}<br>}<br>});<br>} catch (Throwable e) {<br>log.error("transfer many message by pagecache exception", e);<br>getMessageResult.release();<br>}<br><br>response = null;<br>}<br>break;<br>case ResponseCode.PULL_NOT_FOUND:<br><br>if (brokerAllowSuspend && hasSuspendFlag) {<br>long pollingTimeMills = suspendTimeoutMillisLong;<br>if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) {<br>pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();<br>}<br><br>String topic = requestHeader.getTopic();<br>long offset = requestHeader.getQueueOffset();<br>int queueId = requestHeader.getQueueId();<br>PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills, this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);<br>this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);<br>response = null;<br>break;<br>}<br><br>case ResponseCode.PULL_RETRY_IMMEDIATELY:<br>break;<br>case ResponseCode.PULL_OFFSET_MOVED:<br>if (this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE \|\| this.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) {<br>MessageQueue mq = new MessageQueue();<br>mq.setTopic(requestHeader.getTopic());<br>mq.setQueueId(requestHeader.getQueueId());<br>mq.setBrokerName(this.brokerController.getBrokerConfig().getBrokerName());<br><br>OffsetMovedEvent event = new OffsetMovedEvent();<br>event.setConsumerGroup(requestHeader.getConsumerGroup());<br>event.setMessageQueue(mq);<br>event.setOffsetRequest(requestHeader.getQueueOffset());<br>event.setOffsetNew(getMessageResult.getNextBeginOffset());<br>this.generateOffsetMovedEvent(event);<br>log.warn(<br>"PULL_OFFSET_MOVED:correction offset. topic={}, groupId={}, requestOffset={}, newOffset={}, suggestBrokerId={}",<br>requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),<br>responseHeader.getSuggestWhichBrokerId());<br>} else {<br>responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());<br>response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);<br>log.warn("PULL_OFFSET_MOVED:none correction. topic={}, groupId={}, requestOffset={}, suggestBrokerId={}",<br>requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),<br>responseHeader.getSuggestWhichBrokerId());<br>}<br><br>break;<br>default:<br>assert false;<br>}<br>} else {<br>response.setCode(ResponseCode.SYSTEM_ERROR);<br>response.setRemark("store getMessage return null");<br>}<br><br>boolean storeOffsetEnable = brokerAllowSuspend;<br>storeOffsetEnable = storeOffsetEnable && hasCommitOffsetFlag;<br>storeOffsetEnable = storeOffsetEnable && this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;<br>if (storeOffsetEnable) {<br>//自动提交位点<br>this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),<br>requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());<br>}<br>return response;<br>}|
|:----|


|public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset,<br>final int maxMsgNums, final MessageFilter messageFilter) {<br>//消息存储服务关闭则退出<br>if (this.shutdown) {<br>log.warn("message store has shutdown, so getMessage is forbidden");<br>return null;<br>}<br><br>//消息存储服务被设置成不可读则退出<br>if (!this.runningFlags.isReadable()) {<br>log.warn("message store is not readable, so getMessage is forbidden " + this.runningFlags.getFlagBits());<br>return null;<br>}<br><br>//获取当前系统时间<br>long beginTime = this.getSystemClock().now();<br><br>//初始化getMessage的状态<br>GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;<br>long nextBeginOffset = offset;<br>long minOffset = 0;<br>long maxOffset = 0;<br><br>//构建getMessage请求<br>GetMessageResult getResult = new GetMessageResult();<br><br>//获取commitLog最大位点<br>final long maxOffsetPy = this.commitLog.getMaxOffset();<br><br>//根据topic和queueId获取逻辑consumerQueue<br>ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);<br>if (consumeQueue != null) {<br>//分别从cq中获取最大和最小位点，作为边界值<br>minOffset = consumeQueue.getMinOffsetInQueue();<br>maxOffset = consumeQueue.getMaxOffsetInQueue();<br><br>//处理边界值不合法的情况<br>if (maxOffset == 0) {<br>status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;<br>nextBeginOffset = nextOffsetCorrection(offset, 0);<br>} else if (offset < minOffset) {<br>status = GetMessageStatus.OFFSET_TOO_SMALL;<br>nextBeginOffset = nextOffsetCorrection(offset, minOffset);<br>} else if (offset == maxOffset) {<br>status = GetMessageStatus.OFFSET_OVERFLOW_ONE;<br>nextBeginOffset = nextOffsetCorrection(offset, offset);<br>} else if (offset > maxOffset) {<br>status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;<br>if (0 == minOffset) {<br>nextBeginOffset = nextOffsetCorrection(offset, minOffset);<br>} else {<br>nextBeginOffset = nextOffsetCorrection(offset, maxOffset);<br>}<br>}<br>//位点在边界值内的情况<br>else {<br>SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);<br>if (bufferConsumeQueue != null) {<br>try {<br>status = GetMessageStatus.NO_MATCHED_MESSAGE;<br><br>//下一个物理文件的开始位点<br>long nextPhyFileStartOffset = Long.MIN_VALUE;<br>//正在拉取的最大物理位点<br>long maxPhyOffsetPulling = 0;<br><br>int i = 0;<br>//最大的过滤消息数<br>final int maxFilterMessageCount = Math.max(16000, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);<br>//磁盘失败记录<br>final boolean diskFallRecorded = this.messageStoreConfig.isDiskFallRecorded();<br>//new一个cq扩展类<br>ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit();<br>for (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {<br>long offsetPy = bufferConsumeQueue.getByteBuffer().getLong();<br>int sizePy = bufferConsumeQueue.getByteBuffer().getInt();<br>long tagsCode = bufferConsumeQueue.getByteBuffer().getLong();<br><br>maxPhyOffsetPulling = offsetPy;<br><br>//一定等于Long.MIN_VALUE？<br>if (nextPhyFileStartOffset != Long.MIN_VALUE) {<br>if (offsetPy < nextPhyFileStartOffset) {<br>continue;<br>}<br>}<br><br>//检查提交的位点是否在磁盘上<br>boolean isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);<br><br>if (this.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(), isInDisk)) {<br>break;<br>}<br><br>boolean extRet = false, isTagsCodeLegal = true;<br>if (consumeQueue.isExtAddr(tagsCode)) {<br>//从CQ中读取Ext<br>extRet = consumeQueue.getExt(tagsCode, cqExtUnit);<br>if (extRet) {<br>//获取tag的编码形式<br>tagsCode = cqExtUnit.getTagsCode();<br>} else {<br>// can't find ext content.Client will filter messages by tag also.<br>log.error("[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}, topic={}, group={}",<br>tagsCode, offsetPy, sizePy, topic, group);<br>isTagsCodeLegal = false;<br>}<br>}<br>//如果消息过滤器不为空且CQ中没有被匹配的消息<br>if (messageFilter != null<br>&& !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) {<br>if (getResult.getBufferTotalSize() == 0) {<br>status = GetMessageStatus.NO_MATCHED_MESSAGE;<br>}<br><br>continue;<br>}<br>//根据物理位点和物理大小获取buffer<br>SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);<br>if (null == selectResult) {<br>if (getResult.getBufferTotalSize() == 0) {<br>status = GetMessageStatus.MESSAGE_WAS_REMOVING;<br>}<br>//根据物理位点获取下一个物理文件开始位点<br>nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy);<br>continue;<br>}<br><br><br>if (messageFilter != null && !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), null)) {<br>if (getResult.getBufferTotalSize() == 0) {<br>status = GetMessageStatus.NO_MATCHED_MESSAGE;<br>}<br>// release...<br>selectResult.release();<br>continue;<br>}<br><br>this.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();<br>getResult.addMessage(selectResult);<br>status = GetMessageStatus.FOUND;<br>nextPhyFileStartOffset = Long.MIN_VALUE;<br>}<br><br>if (diskFallRecorded) {<br>long fallBehind = maxOffsetPy - maxPhyOffsetPulling;<br>brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);<br>}<br><br>nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);<br><br>long diff = maxOffsetPy - maxPhyOffsetPulling;<br>long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE<br>* (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0));<br>getResult.setSuggestPullingFromSlave(diff > memory);<br>} finally {<br><br>bufferConsumeQueue.release();<br>}<br>} else {<br>status = GetMessageStatus.OFFSET_FOUND_NULL;<br>nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));<br>log.warn("consumer request topic: " + topic + "offset: " + offset + " minOffset: " + minOffset + " maxOffset: "<br>+ maxOffset + ", but access logic queue failed.");<br>}<br>}<br>} else {<br>status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;<br>nextBeginOffset = nextOffsetCorrection(offset, 0);<br>}<br><br>if (GetMessageStatus.FOUND == status) {<br>this.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();<br>} else {<br>this.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();<br>}<br>long elapsedTime = this.getSystemClock().now() - beginTime;<br>this.storeStatsService.setGetMessageEntireTimeMax(elapsedTime);<br><br>getResult.setStatus(status);<br>getResult.setNextBeginOffset(nextBeginOffset);<br>getResult.setMaxOffset(maxOffset);<br>getResult.setMinOffset(minOffset);<br>return getResult;<br>}|
|:----|


